using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System;
using System.Linq;
using UnityEngine.SceneManagement;
using UnityEngine.XR;

public class PreStudy : MonoBehaviour
{
    // Targets and distractors holder. Currently are green sphere, green triangle, red sphere.
    public GameObject[] Objects;

    // Amount of red spheres.
    private int N_redSphere = 0;
    System.Random rnd = new System.Random();

    // Amount of total items.
    public int totalItems = 50;

    // Participant's answer.
    private int result = 0;

    // Radius: ditance between targets and camera.
    private float time = 0, radius = 5.0F;

    // Flag for trials start/stop and file flush on/off.
    private bool start = false, writefile = false;
    //private List<Vector3> headRotation = new List<Vector3>();
    [SerializeField]
    private RestFramesGenerator RestFrames;
    [SerializeField]
    private GameObject HeadSet;
    [SerializeField]
    private GameObject LoadingAnimation;
    [SerializeField]
    private Camera camera;

    private enum targetInFOV { FullFOV, HalfFOV, QuarterFOV};

    [SerializeField]
    private targetInFOV targetRender;

    // The amount of targets (red sphere). Eventual rendered amount will be an int in [N_targets, N_targets+2]
    [SerializeField]
    private int N_targets = 5;
    // Target's parent.
    [SerializeField]
    private GameObject anchor;

    // Target's size, default is 1.
    [SerializeField]
    private float size;

    private int SubjectID = 19;
    [SerializeField]
    private int trials = 3;

    // Next scene.
    [SerializeField]
    private string sceneName = "";

    // Demo Flag.
    [SerializeField]
    private bool demo;

    [SerializeField]
    private bool preTest;

    // Items holder
    private List<GameObject> particles = new List<GameObject>();
    string paraFilePath = "Assets/CSV/PreStudyResult/subject_";

    // Flag pool for target's rendering.
    private bool[] indexLabel = new bool[] { false,false, false, false, false, false, false,false,false,false,false,false,false,false,false,false,false,false };

    private Vector3[] pos;

    // Position pool for target's rendering. 
    // Each element is corresponding index in the position array generated by function EvenDisribution.
    private int[] indexPool = new int[] {0, 65, 37, 34, 55, 18, 40, 50, 20, 17, 60, 39, 38, 35,9, 16,3,22 };
    // Eventually rendered target list.
    private List<int> targetIndex = new List<int>();

    void Start()
    {
        // Disable headset translation tracking.
        switch (targetRender)
        {
            case targetInFOV.FullFOV:
                for(int i = 0; i < indexPool.Count(); i++)
                {
                    indexPool[i] = (int) (indexPool[i] * 3.12F);
                }
                break;
            case targetInFOV.HalfFOV:
                for (int i = 0; i < indexPool.Count(); i++)
                {
                    indexPool[i] = (int)(indexPool[i] * 1.5F);
                }
                break;
            case targetInFOV.QuarterFOV: 
            default:
                break;
        }
        InputTracking.disablePositionalTracking = true;
        if (!preTest)
        {
            paraFilePath = paraFilePath + SubjectID.ToString() + "_" + SceneManager.GetActiveScene().name + ".csv";
        }
        else
        {
            string size = "";
            if(RestFrames.angularSize == 0.26f)
            {
                size = "0" + (RestFrames.angularSize*100).ToString();
            }
            else
            {
                size = "0" + (RestFrames.angularSize * 10).ToString();
            }
            if(RestFrames.angularSize == 1)
            {
                paraFilePath = paraFilePath + SubjectID.ToString() + "_" + "Baseline.csv";
            }
            else if(RestFrames.angularSize == 10)
            {
                paraFilePath = paraFilePath + SubjectID.ToString() + "_" + "FOVRestrictor.csv";
            }
            else
            {
                paraFilePath = paraFilePath + SubjectID.ToString() + "_" + size + "_" + (RestFrames.densityPercentage * 100).ToString() + ".csv";

            }

        }
        CreateCSVFile(paraFilePath);
        foreach(GameObject i in Objects)
        {
            i.transform.localScale = new Vector3(size, size, size);
        }
        pos = EvenDisribution(totalItems);

    }

    private void Update()
    {
        #region Start trial
        if (Input.GetKeyDown(KeyCode.S) && ! start)
        {
            if(trials == 0)
            {
                LoadingAnimation.SetActive(true);
                SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Single);
            }
            start = true;
            time = 0;
            result = 0;
            N_redSphere = rnd.Next(N_targets, N_targets+6);
            InitObjects(false);
        }
        if (start && ! writefile)
        {
            time += Time.deltaTime;
        }
        #endregion

        #region End trial
        if (Input.GetAxis("RightTrigger") > 0.1F && start)
        {
            writefile = true;
            start = false;
            foreach(GameObject m in particles)
            {
                DestroyImmediate(m);
            }
        }
        #endregion

        #region Input answer and updats CSV file
        for (int i =0; i < 10; i++)
        {
            if (Input.GetKeyDown("["+i.ToString()+"]"))
            {
                result = result*10 + i;
            }
        }
        if(!demo && (Input.GetKeyDown(KeyCode.Return)  && writefile) )
        {
            File.AppendAllText(paraFilePath, ",,," + "="+result.ToString() +","+"=" + N_redSphere.ToString()+"," + time.ToString() + Environment.NewLine);
            //headRotation.Clear();
            writefile = false;
            trials -= 1;
        }
        // Skip writing CSV when Demo, and use right Enter to finish current trial 
        else if (demo && Input.GetKeyDown(KeyCode.Return))
        {
            writefile = false;
            trials -= 1;
        }
        #endregion
    }

    #region Head rotation tracking
    private void FixedUpdate()
    {
        Vector3 rot = HeadSet.transform.localEulerAngles;
        if (start && !writefile)
        {
            string head_rot = rot.x.ToString() + ", " + rot.y.ToString() + ", " + rot.z.ToString();
            File.AppendAllText(paraFilePath, head_rot + Environment.NewLine);
        }
    }
    #endregion

    void CreateCSVFile(string path)
    {
        if (!File.Exists(path))
        {
            StreamWriter writer = new StreamWriter(path);
            writer.WriteLine("HeadSet Rotation X, HeadSet Rotation Y, HeadSet Rotation Z, Result, TotalSpheres, Time");
            writer.Flush();
            writer.Close();
        }
    }


    #region Gaussian distributed position
    float normalVariate(double mean = 0, double stdDev = 1)
    {
        double u, v, S;
        do
        {
            u = 2.0 * UnityEngine.Random.value - 1.0;
            v = 2.0 * UnityEngine.Random.value - 1.0;
            S = u * u + v * v;
        }
        while (S >= 1);
        double fac = Mathf.Sqrt(-2.0f * Mathf.Log((float)S) / (float)S);
        return (float)(u * fac);
    }
    #endregion

    #region Initialize items
    void InitObjects(bool random)
    {
        int currentIndex = 0;
        float x = 0;
        float y = 0;
        float z = 0;
        float r = 0;

        // Amount of rendered reg sphere
        int rr = 0;

        int currentSphere = 1;

        GameObject tmp;
        targetIndex.Clear();

        // Reset flag pool for target rendering
        for(int m =0; m < indexLabel.Count(); m++)
        {
            indexLabel[m] = false;
        }

        // Randomly intialize red sphere within the position pool
        while(rr < N_redSphere)
        {
            currentIndex = rnd.Next(0, indexPool.Count());
            if (indexLabel[currentIndex])
            {
                continue;
            }
            else
            {
                indexLabel[currentIndex] = !indexLabel[currentIndex];
                targetIndex.Add(indexPool[currentIndex]);
                rr++;
            }
        }

        for (var k = 0; k <pos.Count(); k++)
        {
            #region Calculate Coordinates
            if (random)
            {
                x = normalVariate();
                y = normalVariate();
                z = normalVariate();
                r = Mathf.Sqrt(x * x + y * y + z * z);
                x /= r;
                y /= r;
                z /= r;
            }
            else
            {
                x = pos[k].x;
                y = pos[k].y;
                z = pos[k].z;
            }
            #endregion

            #region Initialize Objects
            if(currentSphere <= N_redSphere && targetIndex.Contains(k))
            {
                tmp = (GameObject)Instantiate((GameObject)Objects[0], new Vector3(0, 0, 0), Quaternion.identity);
                currentSphere += 1;
            }
            else
            {
 
                if(rnd.Next(1,3)%2 == 0)
                {
                    tmp = Instantiate(Objects[1], new Vector3(0, 0, 0), Quaternion.identity);
                }
                else
                {
                    tmp = Instantiate(Objects[2], new Vector3(0, 0, 0), Quaternion.identity);
                }
            }
            tmp.transform.parent = anchor.transform;
            tmp.transform.localPosition = new Vector3(x * radius, y * radius, z * radius);
            tmp.transform.LookAt(camera.transform);
            tmp.name = k.ToString();
            Vector3 rot = tmp.transform.rotation.eulerAngles;
            rot = new Vector3(rot.x + 180, rot.y, rot.z);
            tmp.transform.rotation = Quaternion.Euler(rot);
            particles.Add(tmp);
            #endregion
        }
        N_redSphere = currentSphere-1;
    }
    #endregion

    #region Postion Generation
    Vector3[] EvenDisribution(int n)
    {
        List<Vector3> upts = new List<Vector3>();
        IEnumerable<double> indices = Enumerable.Range(0, n).Select(a => (double)a + 0.5); ;
        double phi = 0, theta = 0;
        double x = 0, y = 0, z = 0;
        int m = 0;
        foreach (double i in indices)
        {
            phi = Math.Acos(1 - 2 * i / n);
            theta = Math.PI * (1 + Math.Sqrt(5)) * i;
            if (targetRender == targetInFOV.HalfFOV && (theta % (2*Math.PI)) > Math.PI)
            {
                continue;
            }
            else if(targetRender == targetInFOV.QuarterFOV && ((theta % (2 * Math.PI)) > Math.PI || (phi < Math.PI/4 || phi > 3*Math.PI/4)))
            {
                continue;
            }
            x = Math.Cos(theta) * Math.Sin(phi);
            y = Math.Cos(phi);
            z = Math.Sin(theta) * Math.Sin(phi);
            upts.Add(new Vector3((float)x, (float)y, (float)z));
        }
        Vector3[] pts = upts.ToArray();
        return pts;
    }
    #endregion
}
